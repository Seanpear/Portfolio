<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sean Pearson">
<meta name="author" content="Nick Beegle">

<title>ESS 330 Final Project Proposals</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="ESS330-Project-Proposal_files/libs/clipboard/clipboard.min.js"></script>
<script src="ESS330-Project-Proposal_files/libs/quarto-html/quarto.js"></script>
<script src="ESS330-Project-Proposal_files/libs/quarto-html/popper.min.js"></script>
<script src="ESS330-Project-Proposal_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ESS330-Project-Proposal_files/libs/quarto-html/anchor.min.js"></script>
<link href="ESS330-Project-Proposal_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ESS330-Project-Proposal_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ESS330-Project-Proposal_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ESS330-Project-Proposal_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ESS330-Project-Proposal_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ESS 330 Final Project Proposals</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Sean Pearson </p>
             <p>Nick Beegle </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="project-focus-investigate-how-the-of-impervious-surfaces-affects-water-quality-nutrient-pollution-turbidity-and-streamflow-flashiness-how-rapidly-streams-fall-and-rise-in-response-to-rain." class="level2">
<h2 class="anchored" data-anchor-id="project-focus-investigate-how-the-of-impervious-surfaces-affects-water-quality-nutrient-pollution-turbidity-and-streamflow-flashiness-how-rapidly-streams-fall-and-rise-in-response-to-rain.">Project Focus: Investigate how the % of impervious surfaces affects: water quality (nutrient pollution, turbidity) and streamflow flashiness (how rapidly streams fall and rise in response to rain).</h2>
</section>
<section id="seans-proposal-1-effects-of-impervious-surface-on-stream-flashiness-in-colorado-watersheds" class="level2">
<h2 class="anchored" data-anchor-id="seans-proposal-1-effects-of-impervious-surface-on-stream-flashiness-in-colorado-watersheds">Sean’s Proposal 1: Effects of Impervious Surface on Stream Flashiness in Colorado Watersheds</h2>
<section id="justification" class="level3">
<h3 class="anchored" data-anchor-id="justification">Justification</h3>
<p>As urban areas expand, impervious surfaces such as roads, rooftops, and parking lots disrupt natural hydrology, leading to increased runoff and more variable streamflows (Walsh et al., 2005). This phenomenon, known as streamflow flashiness, can cause erosion, degrade habitat, and amplify flood risks. Measuring this flashiness in relation to watershed imperviousness offers insights into the consequences of urban development on stream behavior, particularly in semi-arid regions like Colorado where hydrologic responses may be more pronounced. Understanding this relationship is essential for guiding sustainable development and improving watershed management.</p>
</section>
<section id="research-objective-hypothesis" class="level3">
<h3 class="anchored" data-anchor-id="research-objective-hypothesis">Research Objective / Hypothesis</h3>
<p>Objective: to evaluate how percent impervious surface in Colorado watersheds affects streamflow flashiness. Hypothesis: Watersheds with higher impervious surface coverage will exhibit significantly higher streamflow flashiness, measured using the Richards-Baker Index.</p>
</section>
<section id="proposed-methods" class="level3">
<h3 class="anchored" data-anchor-id="proposed-methods">Proposed Methods</h3>
<p>We will extract percent impervious surface using the NLCD rasterdataset clipped to watersheds. Streamflow data will be retrieved from USGS NWIS using the dataRetrieval R package. We will calculate the Richards-Baker Flashiness Index using daily discharge data from 2010–2020 at selected gaging stations across multiple land use gradients. Watersheds will be categorized based on impervious surface % to assess patterns. We will use linear regression to test for statistical correlation between imperviousness and flashiness.</p>
</section>
<section id="expected-outcomes" class="level3">
<h3 class="anchored" data-anchor-id="expected-outcomes">Expected Outcomes</h3>
<p>We expect to find a positive correlation between watershed imperviousness and streamflow flashiness. Higher impervious surface % should correspond to more rapid and variable stream discharge. These results would reinforce the importance of green infrastructure and land use planning in mitigating hydrologic disturbance in urbanizing areas.</p>
<section id="references" class="level4">
<h4 class="anchored" data-anchor-id="references">References</h4>
<p>Walsh, Christopher J, et al.&nbsp;“The Urban Stream Syndrome: Current Knowledge and the Search for a Cure.” ResearchGate, Journal of the North American Benthological Society, Sept.&nbsp;2005, www.researchgate.net/publication/228642919_The_Urban_Stream_Syndrome_Current_Knowledge_and_the_Search_For_A_Cure.</p>
<p>Shuster, William, et al.&nbsp;“(PDF) Impacts of Impervious Surface on Watershed Hydrology: A Review.” Research Gate, Urban Water Journal , Dec.&nbsp;2005, www.researchgate.net/publication/240534535_Impacts_of_Impervious_Surface_on_Watershed_Hydrology_A_Review.</p>
</section>
</section>
</section>
<section id="seans-proposal-2-linking-impervious-surface-coverage-to-nutrient-loading-in-colorado-streams" class="level2">
<h2 class="anchored" data-anchor-id="seans-proposal-2-linking-impervious-surface-coverage-to-nutrient-loading-in-colorado-streams">Sean’s Proposal 2: Linking Impervious Surface Coverage to Nutrient Loading in Colorado Streams</h2>
<section id="justification-1" class="level3">
<h3 class="anchored" data-anchor-id="justification-1">Justification</h3>
<p>Urban runoff from impervious surfaces often carries pollutants like nitrogen and phosphorus directly into nearby water bodies without filtration (Paul &amp; Meyer, 2001). This process contributes to nutrient enrichment and eutrophication, which can lead to algal blooms, oxygen depletion, and biodiversity loss (Carpenter et al., 2001). In Colorado, where growing urban centers are expanding into sensitive watersheds, understanding the link between land cover and nutrient pollution is critical. This project seeks to quantify whether higher impervious surface percentages within a watershed are associated with elevated concentrations of nitrogen and phosphorus in streams, informing land-use decisions and watershed protection policies.</p>
<p>###Research Objective / Hypothesis</p>
<p>Objective: to assess how impervious land cover influences nitrogen and phosphorus concentrations in streams across Colorado watersheds. Hypothesis: streams draining watersheds with higher impervious surface area will have higher concentrations of nitrate and phosphorus due to increased urban runoff and reduced filtration.</p>
</section>
<section id="proposed-methods-1" class="level3">
<h3 class="anchored" data-anchor-id="proposed-methods-1">Proposed Methods</h3>
<p>Impervious surface data will be extracted from the NLCD dataset and aggregated within watershed boundaries. Nutrient data will be retrieved using the dataRetrieval R package from the USGS NWIS Water Quality Portal. We will identify sampling sites with both water quality and land cover data. Linear regression models will test relationships between % impervious surface and nutrient concentrations.</p>
</section>
<section id="expected-outcomes-1" class="level3">
<h3 class="anchored" data-anchor-id="expected-outcomes-1">Expected Outcomes</h3>
<p>We expect to find that more urbanized watersheds (with higher impervious surface coverage) have higher nitrate and phosphorus levels in streams. These results would highlight the role of land cover in driving nutrient pollution and support the need for improved stormwater management in urban planning.</p>
<section id="references-1" class="level4">
<h4 class="anchored" data-anchor-id="references-1">References</h4>
<p>Paul, Michael J., and Judy L. Meyer. “Streams in the Urban Landscape.” Annual Review of Ecology, Evolution, and Systematics, Annual Reviews, 1 Nov.&nbsp;2001, www.annualreviews.org/content/journals/10.1146/annurev.ecolsys.32.081501.114040.</p>
<p>Carpenter, S. R., Caraco, N. F., Correll, D. L., Howarth, R. W., Sharpley, A. N., &amp; Smith, V. H. Nonpoint pollution of surface waters with phosphorus and nitrogen. Ecological Applications, Dec.&nbsp;2001, https://www.epa.gov/watershedacademy/nonpoint-source-pollution-nitrogen-and-phosphorus</p>
</section>
</section>
</section>
<section id="nicks-proposal-1-a-historical-analysis-of-impervious-surface-impact-on-water-quality-and-streamflow-flashiness-in-the-poudre-river" class="level2">
<h2 class="anchored" data-anchor-id="nicks-proposal-1-a-historical-analysis-of-impervious-surface-impact-on-water-quality-and-streamflow-flashiness-in-the-poudre-river">Nick’s Proposal 1: A Historical Analysis of Impervious Surface Impact on Water Quality and Streamflow Flashiness in the Poudre River</h2>
<section id="justification-2" class="level3">
<h3 class="anchored" data-anchor-id="justification-2">Justification:</h3>
<p>The Poudre River has seen increasing urban development around Fort Collins over the last few decades. As impervious surfaces such as roads and buildings expand, water quality and flow patterns in the river may be affected. This study is a chance to understand long-term local trends and inform future urban planning and watershed management. Research Objective/Question/Hypothesis: How has the increase in impervious land cover over time affected water quality (e.g., nutrient concentrations, turbidity) and streamflow flashiness in the Poudre River?</p>
</section>
<section id="hypothesis" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis">Hypothesis</h3>
<p>Increases in impervious surface area over time have contributed to decreased water quality and increased streamflow flashiness.</p>
</section>
<section id="proposed-methods-2" class="level3">
<h3 class="anchored" data-anchor-id="proposed-methods-2">Proposed Methods</h3>
<p>Collect historical land cover data (NLCD datasets) for the Fort Collins region. Access water quality and streamflow data from USGS gages on the Poudre River. Use basic R statistical tools such as linear regression to assess relationships over time. Create time series plots and correlation analyses. Potentially calculate the Richards-Baker Flashiness Index.</p>
</section>
<section id="expected-outcomes-2" class="level3">
<h3 class="anchored" data-anchor-id="expected-outcomes-2">Expected Outcomes</h3>
<p>A visualization of how impervious surface area, water quality metrics, and flashiness have changed over time. Evidence of positive correlations between urbanization and stress on the watershed surrounding Fort Collins. A simple regression model showing relationship strength.</p>
</section>
<section id="sources" class="level3">
<h3 class="anchored" data-anchor-id="sources">Sources</h3>
<p>Multi-Resolution Land Characteristics (MRLC) Consortium. (n.d.). Data: Fractional Impervious Surface. U.S. Geological Survey. Retrieved April 18, 2025, from https://www.mrlc.gov/data?f%5B0%5D=category%3AFractional%20Impervious%20Surface U.S. Geological Survey. (n.d.). USGS 06752260 Cache la Poudre River at Fort Collins, CO. National Water Information System. Retrieved April 18, 2025, from https://waterdata.usgs.gov/nwis/inventory/?site_no=06752260&amp;agency_cd=USGS</p>
</section>
</section>
<section id="nicks-proposal-2-evaluating-water-quality-and-flashiness-before-and-after-green-infrastructure-efforts-in-portland-oregon" class="level2">
<h2 class="anchored" data-anchor-id="nicks-proposal-2-evaluating-water-quality-and-flashiness-before-and-after-green-infrastructure-efforts-in-portland-oregon">Nick’s Proposal 2: Evaluating Water Quality and Flashiness Before and After Green Infrastructure Efforts in Portland, Oregon</h2>
<section id="justification-3" class="level3">
<h3 class="anchored" data-anchor-id="justification-3">Justification</h3>
<p>Portland, Oregon has been a leader in implementing green infrastructure (like permeable pavement, rain gardens, and green roofs) to reduce stormwater runoff and mitigate the effects of impervious surfaces. This project will examine whether these efforts have had measurable impacts on stream water quality and flow variability over time. Research Objective/Question/Hypothesis: How have Portland’s efforts to reduce impervious surface impacts through green infrastructure influenced local stream water quality and flashiness over time?</p>
</section>
<section id="hypothesis-1" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-1">Hypothesis</h3>
<p>Water quality has improved and streamflow flashiness has decreased in areas where green infrastructure was implemented, compared to earlier periods.</p>
</section>
<section id="proposed-methods-3" class="level3">
<h3 class="anchored" data-anchor-id="proposed-methods-3">Proposed Methods</h3>
<p>Obtain historical and recent land cover/impervious surface data for Portland using NLCD datasets. Access water quality and streamflow data for streams within Portland from the USGS or the city’s environmental services. Identify timelines and areas where green infrastructure was implemented. Use time series analysis and linear regression in R to compare before vs.&nbsp;after periods. Visualize changes using ggplot and explore trends using dplyr and tidyr</p>
</section>
<section id="expected-outcomes-3" class="level3">
<h3 class="anchored" data-anchor-id="expected-outcomes-3">Expected Outcomes:</h3>
<p>A clear before-and-after comparison of stream conditions in areas impacted by green infrastructure. Evidence (or lack thereof) of water quality improvement and reduced flashiness. Insight into the effectiveness of city-wide impervious surface reduction strategies for stream health.</p>
<section id="sources-1" class="level4">
<h4 class="anchored" data-anchor-id="sources-1">Sources</h4>
<p>Multi-Resolution Land Characteristics (MRLC) Consortium. (n.d.). Data: Fractional Impervious Surface. U.S. Geological Survey. Retrieved April 18, 2025, from https://www.mrlc.gov/data?f%5B0%5D=category%3AFractional%20Impervious%20Surface</p>
<p>City of Portland Bureau of Environmental Services. (n.d.). About Green Streets. Retrieved April 18, 2025, from https://www.portland.gov/bes/stormwater/about-green-streets</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>